## Asynchronous Programming:
  
  ### Synchronous and asynchronous programming: 
   * In `synchronous programming`, one thing happens at a time. When we call a function that performs a long-running action, it returns a result when the action has finished. This stops the program for the time the action takes. 
   * In contrast, `asynchronous programming` allows multiple things to happen at the same time. When we start an action, the program continues to run. When the action finishes, the program is informed and gets the result.
   
 <hr/>



## AJAX:
 * Ajax stands for `Asynchronous JavaScript And XML`. 
 * Ajax loads the data from the server and update the parts of a web page selectively without reloading the whole page. 
 * It is a technique for creating faster, and more interactive web applications with the help of XML, HTML, CSS, and JavaScript. 
 * It is a web browser technology which is independent of web server software.
 * AJAX use the built-in browser `XMLHttpRequest (XHR)` objects to send and receive information to and from a web server asynchronously, in the background, without blocking the page or interfering with the user's experience.
 * Ajax uses XHTML for the content, CSS for designing, along with Document Object Model and JavaScript for dynamic content display. 
 * Before AJAX technology, the web applications used to transmit information to and from the server using synchronous requests. 
 * ### How Does AJAX Work?
      * JavaScript and XML combine to make asynchronous updating happen through the use of something called an XMLHttpRequest (XHR) object. 
      * When the user visits a web page which is designed using AJAX technology, and a prescribed event occurs (a button, or fills out a form) the JavaScript creates an XMLHttpRequest (XHR) object, which then transfers data in an XML format between a web browser and a web. 
      * The XMLHttpRequest(XHR) object sends a request for updated page data to the web server, the server process the request, a response is created at server-side and sent back to the browser, which then uses JavaScript to process the response and display it on the screen as updated content.

<hr/>


## Callback Function:
   * A callback is a function that is executed after another function that has finished executing. 
   * As we have studied earlier that functions are objects. Functions can take functions as arguments and can be returned by other functions. 
   * Functions that take another function as an argument are called higher-order functions. 
   * So, the callback function can also be defined as any function that is passed as an argument.
   * ### Why do we need Callbacks?
      * Callbacks are used to make sure that a function is not going to execute before a task is completed but will execute right after the task has completed. 
      * It helps us develop asynchronous JavaScript code and keeps us safe from future errors.
      * In JavaScript, the way to create a callback function is to pass it as a parameter to another function, and then to call it back right after something has happened or some task is completed.

<hr/>


## Promises:
  * Callback functions were initially used to handle asynchronous operations. 
  * However, callbacks functions were limited in terms of functionality and often led to confusing code, so, promises were introduced to deal with these problems.
  * A `promise` in JavaScript is similar to promises we do in real life. 
  * When we make a promise, it is guaranteed that in future, we are going to do something. 
  * A promise has two possible outcomes: it will be kept when the time comes, or it will not. 
  * Similarly, in JavaScript, when we define a promise, either it will be resolved when the time comes, or it will get rejected. 
  * According to MDN, “the Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.”
  * A promise has three states:
     1. pending: It is the initial state.
     2. Fulfilled: It indicates that the promised operation was successful.
     3. Rejected: It indicates that the promised operation was unsuccessful. 
  * The constructor syntax for a promise object is: 
    ```
    let myPromise = new Promise(function(resolve, reject) {
    // code here
    });
    ```
  * When new Promise is created, the function passed into it runs automatically. 
  * It contains the producing code which produces the result. 
  * Its arguments are resolve and reject. 
  * Example snippet:
    ```
    var promise = new Promise(function(resolve, reject) { 
    const x = "Sanya"; 
    const y = "Sanya"
    if(x === y) { 
      resolve(); 
    } else { 
      reject(); 
    } }); 
    promise.then(function(){ 
    console.log('Success, Promise resolved.');}).catch(function () { 
    console.log('Some error occurred.');}); 
    // Here if the task is successful(x===y), the promise is resolved. 
    // If the task is unsuccessful(x is not equal to y), then the promise is rejected. 
    // The then() method is called if the promise is resolved
    // and the catch() method is called when the promise is rejected or if an error occurred during the code execution.
    ```
  * Promises are the ideal choice for asynchronous programming. 
  * Promises can handle multiple asynchronous operations easily and are better at error handling as compared to callbacks and events.
   
<hr/>

 ## Fetch API:
  * The Fetch API is a promise-based API of JavaScript for making asynchronous HTTP requests in the browser similar to XMLHttpRequest (XHR). 
  * Unlike XHR, the fetch API is a simple and clean API that uses promises to provides more powerful features to fetch resources from the server. 
  * Fetch API is standardized now and is supported by all modern browsers except IE. 
  * The fetch() method only has one mandatory argument: the URL of the resource that we want to fetch.
  * To use a Fetch API, just pass the URL, the path to the resource we want to fetch, to fetch() method. 
  * The syntax is:
  ```
  fetch('/js/users.json')
   .then(response => {
     // handle response data
   })
   .catch(err => {
     // handle errors
   });
  ```
  * We are using the then method to wait for the server's response. The catch() method is optional. 
  * #### We can extract the JSON from that response once the request completes:
    ```
    fetch('URL here')
    .then(res => res.json())
    .then(json => console.log(json));
    ```
    * We start the request by calling fetch(). 
    * When the promise is fulfilled, it returns a response object, which exposes a json method. 
    * Within the first then(), we can call this json method to return the response body as JSON.
  * ### GET Request:
     * GET requests are widely used methods in APIs and websites. 
     * The purpose of this method is to retrieve data from the server at the specified resource. 
     * The Fetch API uses the GET method for asynchronous requests.
     * Example snippet:
      ```
      fetch('https://api.github.com/orgs/nodejs')
      .then(response => response.json())
      .then(data => {
      console.log(data) // Prints result from `response.json()` in getRequest
      })
      .catch(error => console.error(error))
      ```

  * ### POST Request:
     * The purpose of the post request is to send the data to the server and create a new resource. 
     * The resource post request creates subordinate to some other parent resource. 
     * When a new resource is posted to the parent, the API service will automatically associate the new resource by assigning it an ID. 
     * All we need to do is set the method and body parameters in the fetch() options.
     * * Example snippet:
      ```
      let data = {
      first_name: 'John',
      last_name: 'Adams',
      job_title: 'Software Engineer'
      };
      const options = {
       method: 'POST',
       body: JSON.stringify(data),
       headers: {
        'Content-Type': 'application/json'
        }
       }
       fetch('https://reqres.in/api/users', options)
       .then(res => res.json())
       .then(res => console.log(res));
      ```

